---
title: Effect Services
description: How Effect is used for dependency injection, layers, and typed errors in the backend
---

tx-agent-kit uses [Effect](https://effect.website) as the backbone of the backend architecture. Effect provides dependency injection through services and layers, typed error handling, and composable program construction.

## Where Effect is used

Effect is used in five packages:

| Package | How Effect is used |
|---------|-------------------|
| `packages/core` | Service definitions, domain error types, port interfaces |
| `packages/infra/db` | Repository implementations as Effect services |
| `packages/infra/auth` | Auth primitives wrapped as Effect operations |
| `apps/api` | HttpApi server, route handlers, layer composition |
| `apps/worker` | Activity implementations, workflow helpers |

Effect is deliberately excluded from `apps/web` and `apps/mobile`. The frontend apps are pure TypeScript consumers of an HTTP API. They do not need Effect's dependency injection or error handling. They use standard try/catch and API client libraries.

## Services and dependency injection

Effect services are the primary mechanism for dependency injection. A service defines a capability contract:

```typescript
import { Context, Effect } from "effect"

// Define a service tag
export class OrganizationRepository extends Context.Tag("OrganizationRepository")<
  OrganizationRepository,
  {
    readonly findById: (id: string) => Effect.Effect<OrganizationRecord | null>
    readonly create: (input: CreateOrganizationInput) => Effect.Effect<OrganizationRecord>
    readonly listByUser: (userId: string) => Effect.Effect<ReadonlyArray<OrganizationRecord>>
  }
>() {}
```

Code that needs organization persistence depends on `OrganizationRepository` without knowing the implementation:

```typescript
const createOrganization = (input: CreateOrganizationInput) =>
  Effect.gen(function* () {
    const repo = yield* OrganizationRepository
    const org = yield* repo.create(input)
    return org
  })
```

The concrete implementation is provided later through layers.

## Layers for composition

Layers wire concrete implementations to service tags. This is where the dependency injection happens:

```typescript
import { Layer } from "effect"

// Concrete implementation using Drizzle
export const OrganizationRepositoryLive = Layer.succeed(
  OrganizationRepository,
  makeOrganizationRepository(db),
)
```

Layers compose to build the full application:

```typescript
const AppLayer = Layer.mergeAll(
  OrganizationRepositoryLive,
  InvitationRepositoryLive,
  AuthServiceLive,
)

// Run the program with all dependencies provided
Effect.runPromise(
  program.pipe(Effect.provide(AppLayer))
)
```

This composition happens at the application boundary, in `apps/api` route wiring or `apps/worker` bootstrap. Domain code never sees concrete implementations.

## Typed errors

Effect tracks errors in the type system. Every operation declares what errors it can produce:

```typescript
export class OrganizationNotFound extends Data.TaggedError("OrganizationNotFound")<{
  readonly id: string
}> {}

export class InvalidSubscriptionTransition extends Data.TaggedError("InvalidSubscriptionTransition")<{
  readonly from: string
  readonly to: string
}> {}

// The return type includes the error channel
const updateOrganization = (
  id: string,
  input: UpdateOrganizationInput,
): Effect.Effect<OrganizationRecord, OrganizationNotFound> =>
  Effect.gen(function* () {
    const repo = yield* OrganizationRepository
    const org = yield* repo.findById(id)
    if (!org) return yield* Effect.fail(new OrganizationNotFound({ id }))
    // ...
  })
```

Route handlers in the API map these domain errors to HTTP status codes, keeping domain logic free from HTTP concerns.

## HttpApi

The API server uses Effect's HttpApi module to define typed HTTP endpoints:

```typescript
const OrganizationApi = HttpApiGroup.make("organizations").pipe(
  HttpApiGroup.add(
    HttpApiEndpoint.post("createOrganization", "/v1/organizations")
      .setPayload(createOrganizationRequestSchema)
      .addSuccess(organizationSchema)
      .addError(UnauthorizedError, { status: 401 }),
  ),
)
```

This provides automatic request validation from `effect/Schema`, typed error responses with correct HTTP status codes, OpenAPI spec generation from the route definitions, and type-safe handler implementations.

## What Effect is NOT used for

To keep the architecture simple, Effect is not used for frontend state management (the web app uses standard React hooks and `nuqs` for URL state), simple utilities (pure functions in `domain/` are plain TypeScript), or configuration parsing (env modules use typed accessors, not Effect layers).

The rule of thumb: use Effect when you need dependency injection, typed errors, or composable async operations. Use plain TypeScript when you do not.
